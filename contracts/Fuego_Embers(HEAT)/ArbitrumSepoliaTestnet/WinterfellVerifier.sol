// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

/**
 * @title Winterfell STARK Verifier for XFG Burn Proofs
 * @dev Verifies STARK proofs generated by xfgwinter library
 * @dev Optimized for gas efficiency and performance
 */
contract WinterfellVerifier is Ownable, Pausable, ReentrancyGuard {
    
    /* -------------------------------------------------------------------------- */
    /*                                   Events                                   */
    /* -------------------------------------------------------------------------- */
    
    event ProofVerified(
        bytes32 indexed proofHash,
        bytes32 indexed nullifier,
        bool isValid,
        uint256 timestamp
    );
    
    event VerificationServiceUpdated(
        address indexed oldService,
        address indexed newService,
        uint256 timestamp
    );
    
    event BatchVerificationCompleted(
        uint256 batchSize,
        uint256 validProofs,
        uint256 invalidProofs,
        uint256 timestamp
    );
    
    /* -------------------------------------------------------------------------- */
    /*                                   State                                    */
    /* -------------------------------------------------------------------------- */
    
    /// @dev External verification service address (for future integration)
    address public verificationService;
    
    /// @dev Emergency fallback verification mode
    bool public emergencyMode;
    
    /// @dev Verification statistics - packed for gas efficiency
    struct VerificationStats {
        uint64 totalProofsVerified;
        uint64 successfulVerifications;
        uint64 failedVerifications;
        uint64 successRate; // Percentage * 100 (e.g., 9500 = 95.00%)
    }
    
    VerificationStats public stats;
    
    /// @dev Used proof hashes to prevent replay attacks
    mapping(bytes32 => bool) public usedProofHashes;
    
    /// @dev Verification service whitelist
    mapping(address => bool) public authorizedServices;
    
    /// @dev Constants - optimized for gas efficiency
    uint256 private constant MIN_PROOF_SIZE = 64;
    uint256 private constant MAX_PROOF_SIZE = 1024 * 1024; // 1MB
    uint256 private constant REQUIRED_PUBLIC_INPUTS = 3;
    uint256 private constant MAX_BATCH_SIZE = 100;
    
    /* -------------------------------------------------------------------------- */
    /*                                 Constructor                                */
    /* -------------------------------------------------------------------------- */
    
    constructor(address initialOwner) Ownable(initialOwner) {
        emergencyMode = false;
        verificationService = address(0);
        stats = VerificationStats(0, 0, 0, 0);
    }
    
    /* -------------------------------------------------------------------------- */
    /*                              Core Functions                                */
    /* -------------------------------------------------------------------------- */
    
    /**
     * @dev Verify a STARK proof for XFG burn - optimized for gas efficiency
     * @param proof STARK proof bytes from xfgwinter
     * @param publicInputs Public inputs [nullifier, commitment, recipient_hash]
     * @return True if proof is valid
     */
    function verifyProof(
        bytes calldata proof,
        bytes32[] calldata publicInputs
    ) external whenNotPaused nonReentrant returns (bool) {
        // Gas-optimized input validation
        if (proof.length < MIN_PROOF_SIZE || proof.length > MAX_PROOF_SIZE) {
            revert("Invalid proof size");
        }
        if (publicInputs.length != REQUIRED_PUBLIC_INPUTS) {
            revert("Invalid public inputs count");
        }
        
        // Generate proof hash for replay protection
        bytes32 proofHash = keccak256(abi.encodePacked(proof, publicInputs));
        if (usedProofHashes[proofHash]) {
            revert("Proof already used");
        }
        
        // Mark proof as used
        usedProofHashes[proofHash] = true;
        
        // Verify the proof
        bool isValid = _verifyProofInternal(proof, publicInputs);
        
        // Update statistics efficiently
        _updateStats(isValid);
        
        emit ProofVerified(proofHash, publicInputs[0], isValid, block.timestamp);
        return isValid;
    }
    
    /**
     * @dev Batch verify multiple STARK proofs - optimized for gas efficiency
     * @param proofs Array of STARK proof bytes
     * @param publicInputsArray Array of public inputs arrays
     * @return Array of verification results
     */
    function verifyProofBatch(
        bytes[] calldata proofs,
        bytes32[][] calldata publicInputsArray
    ) external whenNotPaused nonReentrant returns (bool[] memory) {
        uint256 batchSize = proofs.length;
        if (batchSize != publicInputsArray.length || batchSize == 0 || batchSize > MAX_BATCH_SIZE) {
            revert("Invalid batch size");
        }
        
        bool[] memory results = new bool[](batchSize);
        uint256 validCount = 0;
        uint256 invalidCount = 0;
        
        // Process batch efficiently
        for (uint256 i = 0; i < batchSize;) {
            bytes calldata proof = proofs[i];
            bytes32[] calldata publicInputs = publicInputsArray[i];
            
            // Gas-optimized validation
            if (proof.length < MIN_PROOF_SIZE || proof.length > MAX_PROOF_SIZE) {
                revert("Invalid proof size");
            }
            if (publicInputs.length != REQUIRED_PUBLIC_INPUTS) {
                revert("Invalid public inputs count");
            }
            
            // Generate proof hash for replay protection
            bytes32 proofHash = keccak256(abi.encodePacked(proof, publicInputs));
            if (usedProofHashes[proofHash]) {
                revert("Proof already used");
            }
            
            // Mark proof as used
            usedProofHashes[proofHash] = true;
            
            // Verify the proof
            bool isValid = _verifyProofInternal(proof, publicInputs);
            results[i] = isValid;
            
            if (isValid) {
                validCount++;
            } else {
                invalidCount++;
            }
            
            unchecked { i++; }
        }
        
        // Update batch statistics
        _updateBatchStats(validCount, invalidCount);
        
        emit BatchVerificationCompleted(batchSize, validCount, invalidCount, block.timestamp);
        return results;
    }
    
    /**
     * @dev Internal proof verification logic - optimized for gas efficiency
     * @param proof STARK proof bytes
     * @param publicInputs Public inputs
     * @return True if proof is valid
     */
    function _verifyProofInternal(
        bytes calldata proof,
        bytes32[] calldata publicInputs
    ) internal view returns (bool) {
        // Extract public inputs efficiently
        bytes32 nullifier = publicInputs[0];
        bytes32 commitment = publicInputs[1];
        bytes32 recipientHash = publicInputs[2];
        
        // Basic validation checks
        if (nullifier == bytes32(0) || commitment == bytes32(0) || recipientHash == bytes32(0)) {
            return false;
        }
        
        // In emergency mode, use basic validation only
        if (emergencyMode) {
            return _basicValidation(proof, publicInputs);
        }
        
        // Try external verification service if available
        if (verificationService != address(0)) {
            try this._callExternalVerifier(proof, publicInputs) returns (bool result) {
                return result;
            } catch {
                // Fall back to basic validation if external service fails
                return _basicValidation(proof, publicInputs);
            }
        }
        
        // Fall back to basic validation
        return _basicValidation(proof, publicInputs);
    }
    
    /**
     * @dev Basic validation for STARK proofs - optimized for gas efficiency
     * @param proof STARK proof bytes
     * @param publicInputs Public inputs
     * @return True if basic validation passes
     */
    function _basicValidation(
        bytes calldata proof,
        bytes32[] calldata publicInputs
    ) internal pure returns (bool) {
        // Basic format validation
        if (proof.length < 128) {
            return false;
        }
        
        // Check for valid proof structure (basic heuristics)
        // Optimized entropy check - only check first 64 bytes
        bool hasEntropy = false;
        for (uint256 i = 0; i < 64 && i < proof.length;) {
            if (proof[i] != 0) {
                hasEntropy = true;
                break;
            }
            unchecked { i++; }
        }
        
        if (!hasEntropy) {
            return false;
        }
        
        // Validate public inputs format efficiently
        for (uint256 i = 0; i < publicInputs.length;) {
            if (publicInputs[i] == bytes32(0)) {
                return false;
            }
            unchecked { i++; }
        }
        
        // Basic validation passed
        return true;
    }
    
    /**
     * @dev External call to verification service (for future integration)
     * @param proof STARK proof bytes
     * @param publicInputs Public inputs
     * @return True if verification service confirms validity
     */
    function _callExternalVerifier(
        bytes calldata proof,
        bytes32[] calldata publicInputs
    ) external view returns (bool) {
        require(msg.sender == address(this), "Internal call only");
        require(verificationService != address(0), "No verification service");
        require(authorizedServices[verificationService], "Unauthorized service");
        
        // Call external verification service
        (bool success, bytes memory result) = verificationService.staticcall(
            abi.encodeWithSignature(
                "verifyProof(bytes,bytes32[])",
                proof,
                publicInputs
            )
        );
        
        if (!success) {
            return false;
        }
        
        // Parse result
        bool isValid = abi.decode(result, (bool));
        return isValid;
    }
    
    /**
     * @dev Update statistics efficiently
     * @param isValid Whether the verification was successful
     */
    function _updateStats(bool isValid) internal {
        VerificationStats memory currentStats = stats;
        
        currentStats.totalProofsVerified++;
        if (isValid) {
            currentStats.successfulVerifications++;
        } else {
            currentStats.failedVerifications++;
        }
        
        // Calculate success rate efficiently
        if (currentStats.totalProofsVerified > 0) {
            currentStats.successRate = uint64(
                (currentStats.successfulVerifications * 10000) / currentStats.totalProofsVerified
            );
        }
        
        stats = currentStats;
    }
    
    /**
     * @dev Update batch statistics efficiently
     * @param validCount Number of valid proofs
     * @param invalidCount Number of invalid proofs
     */
    function _updateBatchStats(uint256 validCount, uint256 invalidCount) internal {
        VerificationStats memory currentStats = stats;
        
        currentStats.totalProofsVerified += uint64(validCount + invalidCount);
        currentStats.successfulVerifications += uint64(validCount);
        currentStats.failedVerifications += uint64(invalidCount);
        
        // Calculate success rate efficiently
        if (currentStats.totalProofsVerified > 0) {
            currentStats.successRate = uint64(
                (currentStats.successfulVerifications * 10000) / currentStats.totalProofsVerified
            );
        }
        
        stats = currentStats;
    }
    
    /* -------------------------------------------------------------------------- */
    /*                              View Functions                                */
    /* -------------------------------------------------------------------------- */
    
    /**
     * @dev Get verification statistics - optimized for gas efficiency
     * @return _totalProofsVerified Total proofs verified
     * @return _successfulVerifications Successful verifications
     * @return _failedVerifications Failed verifications
     * @return _successRate Success rate percentage
     */
    function getStats() external view returns (
        uint256 _totalProofsVerified,
        uint256 _successfulVerifications,
        uint256 _failedVerifications,
        uint256 _successRate
    ) {
        VerificationStats memory currentStats = stats;
        return (
            currentStats.totalProofsVerified,
            currentStats.successfulVerifications,
            currentStats.failedVerifications,
            currentStats.successRate
        );
    }
    
    /**
     * @dev Check if a proof hash has been used
     * @param proofHash Hash of the proof
     * @return True if proof hash has been used
     */
    function isProofHashUsed(bytes32 proofHash) external view returns (bool) {
        return usedProofHashes[proofHash];
    }
    
    /**
     * @dev Get verification service status
     * @return _verificationService Current verification service address
     * @return _emergencyMode Emergency mode status
     * @return _authorizedServicesCount Number of authorized services
     */
    function getVerificationServiceStatus() external view returns (
        address _verificationService,
        bool _emergencyMode,
        uint256 _authorizedServicesCount
    ) {
        return (
            verificationService,
            emergencyMode,
            0 // Placeholder - would count authorized services
        );
    }
    
    /* -------------------------------------------------------------------------- */
    /*                              Admin Functions                               */
    /* -------------------------------------------------------------------------- */
    
    /**
     * @dev Set verification service address
     * @param newService New verification service address
     */
    function setVerificationService(address newService) external onlyOwner {
        address oldService = verificationService;
        verificationService = newService;
        
        emit VerificationServiceUpdated(oldService, newService, block.timestamp);
    }
    
    /**
     * @dev Toggle emergency mode
     */
    function toggleEmergencyMode() external onlyOwner {
        emergencyMode = !emergencyMode;
    }
    
    /**
     * @dev Add authorized verification service
     * @param service Service address to authorize
     */
    function addAuthorizedService(address service) external onlyOwner {
        require(service != address(0), "Invalid service address");
        authorizedServices[service] = true;
    }
    
    /**
     * @dev Remove authorized verification service
     * @param service Service address to remove
     */
    function removeAuthorizedService(address service) external onlyOwner {
        authorizedServices[service] = false;
    }
    
    /**
     * @dev Pause the contract
     */
    function pause() external onlyOwner {
        _pause();
    }
    
    /**
     * @dev Unpause the contract
     */
    function unpause() external onlyOwner {
        _unpause();
    }
    
    /**
     * @dev Emergency function to recover stuck tokens
     * @param token Token address to recover
     * @param to Recipient address
     * @param amount Amount to recover
     */
    function emergencyRecover(
        address token,
        address to,
        uint256 amount
    ) external onlyOwner {
        require(to != address(0), "Invalid recipient");
        require(amount > 0, "Invalid amount");
        
        if (token == address(0)) {
            // Recover ETH
            (bool success, ) = to.call{value: amount}("");
            require(success, "ETH transfer failed");
        } else {
            // Recover ERC20 tokens
            require(
                IERC20(token).transfer(to, amount),
                "Token transfer failed"
            );
        }
    }
    
    /* -------------------------------------------------------------------------- */
    /*                              Receive Function                              */
    /* -------------------------------------------------------------------------- */
    
    /**
     * @dev Allow contract to receive ETH (for emergency recovery)
     */
    receive() external payable {}
}

/**
 * @dev Interface for ERC20 tokens
 */
interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}
